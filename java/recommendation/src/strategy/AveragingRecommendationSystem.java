package strategy;

import graphframework.TrustGraph;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import dataframework.Trust;
import dataframework.User;

/**
 * Recommendation system that uses synchronized message passing in order to produce its 
 * recommendations for a give {@link TrustGraph}. In each turn, each vertex is receiving
 * recommendations from its trusted (out-going edges) neighbors and itself sending a
 * recommendation to its trusting (in-going edges) vertices while updating its own value.
 * Process ignite itself by messages generated by the voters. The value of each user is the
 * average of each of its received recommendations in the last step. The message for each user
 * is unique by two means. First each user's recommendation to its friend may be uniquly 
 * mapped using a specified {@link VotesMapper}. Second, vertices may ignore other vertex's
 * recommendation when updating each other. Last will make the system work in 'belief 
 * propagation' mode. Messages are sent up to a specified budget and this should be used
 * carefully in order to tradeoff between accuracy and running time. This method is to be 
 * later changed so it will run until a convergence is reached.
 *  
 * @see VotesMapper
 * @see BeliefPropagationRecommendationSystem
 * 
 * @author mizrachi
 *
 */
public class AveragingRecommendationSystem implements RecommendationStrategy {
	
	private int totalMessagesBudget;
	
	private Map<MessageKey, VotesDistributionMessage> messagesToSendMap;
	
	private Map<MessageKey, VotesDistributionMessage> messagesReceivedMap;
	
	private VotesMapper votesMapper;
	
	/**when this value is <code>true</code>, the average for vertex v do not contain his own  
	 * subjective 'opinion' but only what the vertices he trust 'think'
	 * so the system works in belief propagation style. Default value is
	 * <code>false</code>*/
	protected final boolean ignoreUpdatedVertexValue;
	
	public AveragingRecommendationSystem(int totalMessagesBudget) {
		this(totalMessagesBudget, false, new TransparentVotesMapper());
	}
	
	public AveragingRecommendationSystem(int totalMessagesBudget, boolean ignoreUpdatedVertexValue, VotesMapper votesMapper) {
		this.totalMessagesBudget = totalMessagesBudget;
		this.messagesToSendMap = new HashMap<MessageKey, VotesDistributionMessage>();
		this.messagesReceivedMap = new HashMap<MessageKey, VotesDistributionMessage>();
		this.ignoreUpdatedVertexValue = ignoreUpdatedVertexValue;
		this.votesMapper = votesMapper;
	}
	
	@Override
	public void recommend(TrustGraph graph, Map<Integer, Double> votes,
			Set<User> queries, File output) {
		
		int messagesCount = totalMessagesBudget;
		
		if (votes.isEmpty()) {
			throw new IllegalArgumentException("Voters map is empty. Recommendation can be supplied only if at least single voter exists.");
		}
		
		FileWriter writer = null;
		if (output != null) {
			try {
				writer = new FileWriter(output);
			} catch (IOException e) {
				System.err.println("Could not open output file");
				return;
			}
		}
		
		//initializes graph with initial votes
		int userId;
		for (User user : graph.vertexSet()) {
			user.reset();
			userId = user.getId();
			if (votes.keySet().contains(userId)) {
				user.setVoter(true);
				user.setValue(votes.get(userId));
			} else {
				user.setVoter(false);
				user.setValue(0);
			}
		}		
		messagesToSendMap.clear();
		messagesReceivedMap.clear();
		
		//initialization phase		
		int srcUserId, dstUserId;
		for (User user : graph.vertexSet()) {
			srcUserId = user.getId();
			if (user.isVoter()) {
				for (Trust inEdge : graph.incomingEdgesOf(user)) {
					dstUserId = graph.getEdgeSource(inEdge).getId();
					messagesToSendMap.put(new MessageKey(srcUserId, dstUserId),
							//cast is safe since first value of voters is their vote which is a discrete value
							new VotesDistributionMessage(votesMapper.map(
									srcUserId,	dstUserId, (int) user.getValue())));
				}
			}
		}
		
		initReportFile(writer, graph);
		
		//update phase
		while (messagesCount > 0 && !messagesToSendMap.isEmpty()) {
			
			//outputs current recommendations to file
			report(writer, graph);
			
			//update values
			messagesReceivedMap.clear();
			for (User current : graph.vertexSet()) {				
				//voters never change their vote
				if (!current.isVoter() && messagesCount > 0) {
					double sigma = 0.0;
					double totalWeight = 0.0;
					double outEdgeWeight;
					//this is not a bug, messages are sent on the opposite direction to trust
					for (Trust outEdge : graph.outgoingEdgesOf(current)) {
						MessageKey key = new MessageKey(graph.getEdgeTarget(outEdge).getId(), current.getId());
						VotesDistributionMessage sent = messagesToSendMap.get(key);
						if (sent != null && sent.isValuable()) {
							outEdgeWeight = outEdge.getLevel();
							messagesReceivedMap.put(key, sent);
							sigma += sent.toRecommendation() * outEdgeWeight;
							totalWeight += outEdgeWeight;
							messagesCount--;
						}
					}
					if (totalWeight  != 0) {
						current.setValue(sigma / totalWeight);
					}
				}
			}
			
			//update messages for next step
			messagesToSendMap.clear();
			double[] votesDist;
			int currentUserId;
			for (User current : graph.vertexSet()) {	
				currentUserId = current.getId();
				//voters never change their recommendation to others
				if (!current.isVoter()) {
					double[] sigmas = new double[VotesDistributionMessage.MAX_VOTE];						
					Arrays.fill(sigmas, 0.0);
					double totalWeight = 0.0;
					double outEdgeWeight;
					//this is not a bug, messages are sent on the opposite direction to trust
					for (Trust outEdge : graph.outgoingEdgesOf(current)) {
						MessageKey key = new MessageKey(graph.getEdgeTarget(outEdge).getId(), currentUserId);
						VotesDistributionMessage received = messagesReceivedMap.get(key);
						if (received != null && received.isValuable()) {
							outEdgeWeight = outEdge.getLevel();
							votesDist = received.getVotesDisribution();
							for (int i = 0; i < votesDist.length; i++) {
								sigmas[i] += votesDist[i] * outEdgeWeight;									
							}	
							totalWeight += outEdgeWeight;
						}
					}	
					
					double[] tempSigmas;
					double tempTotalWeight;
					Trust oppositeEdge = null;
					int otherUserId;
					double oppositeEdgeWeight;
					for (Trust inEdge : graph.incomingEdgesOf(current)) {						
						tempSigmas = Arrays.copyOf(sigmas, sigmas.length);
						tempTotalWeight = totalWeight;
						if (ignoreUpdatedVertexValue) {
							oppositeEdge = graph.getEdge(current, graph.getEdgeSource(inEdge));
						}
						otherUserId = graph.getEdgeSource(inEdge).getId();
						
						if (ignoreUpdatedVertexValue && oppositeEdge != null) {
							MessageKey key = new MessageKey(otherUserId, currentUserId);
							VotesDistributionMessage received = messagesReceivedMap.get(key);
							if (received != null && received.isValuable()) {
								votesDist = received.getVotesDisribution();
								oppositeEdgeWeight = oppositeEdge.getLevel();
								for (int i = 0; i < votesDist.length; i++) {
									tempSigmas[i] -= votesDist[i] * oppositeEdgeWeight;									
								}	
								tempTotalWeight -= oppositeEdgeWeight;
							}							
						}
						
						//normalizing
						for (int i = 0; i < tempSigmas.length; i++) {
							tempSigmas[i] = tempSigmas[i] / tempTotalWeight;
						}
						
						//mapping
						int mappedValue;
						double[] mappedSigmas = new double[VotesDistributionMessage.MAX_VOTE];
						Arrays.fill(mappedSigmas, 0.0);		
						double cluelessSigma = 0;
						for (int i = 0; i < tempSigmas.length; i++) {
							mappedValue = votesMapper.map(currentUserId, otherUserId, i + 1);
							//we don't want to take in account clueless recommendations
							if (mappedValue != VotesDistributionMessage.CLUELESS_REC) {
								mappedSigmas[mappedValue - 1] += tempSigmas[i];								
							} else {
								//so we sum them all
								cluelessSigma += tempSigmas[i];
							}
						}
						//and distribute them among all recommendations.
						if (cluelessSigma > 0) {
							for (int i = 0; i < mappedSigmas.length; i++) {
								mappedSigmas[i] += cluelessSigma / (double) mappedSigmas.length;
							}
						}
						
						//"sending" the message
						if (tempTotalWeight != 0) {
							messagesToSendMap.put(new MessageKey(currentUserId, otherUserId),
									new VotesDistributionMessage(mappedSigmas));
						}
					}					
				} else {
					int otherUserId;
					for (Trust inEdge : graph.incomingEdgesOf(current)) {
						otherUserId = graph.getEdgeSource(inEdge).getId();
						messagesToSendMap.put(new MessageKey(currentUserId, otherUserId),
								//cast is safe since first value of voters is their vote which is a discrete value
								new VotesDistributionMessage(votesMapper.map(
										currentUserId, otherUserId,	(int) current.getValue())));
					}
				}
			}
		}
		
		//report final recommendations and closing file
		report(writer, graph);
		if (writer != null) {
			try {
				writer.close();
			} catch (IOException e) {
				System.err.println("Unable to close output file. Some of the information might be lost");
			}
		}
	}
	
	private void report(FileWriter writer, TrustGraph graph) {
		if (writer != null) {
			try {			
				User[] users  = graph.vertexSet().toArray(new User[0]);
				Arrays.sort(users);
				String lineEnd = "\n";
				char delimiter = ',';
				for (User user : users) {
					writer.write(String.valueOf(user.getValue()));
					writer.write(delimiter);		
				}
				writer.write(lineEnd);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	private void initReportFile(FileWriter writer, TrustGraph graph) {
		if (writer != null) {
			try {			
				User[] users  = graph.vertexSet().toArray(new User[0]);
				Arrays.sort(users);
				String lineEnd = "\n";
				char delimiter = ',';
				for (User user : users) {
					writer.write(String.valueOf(user.getId()));
					writer.write(delimiter);		
				}
				writer.write(lineEnd);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
